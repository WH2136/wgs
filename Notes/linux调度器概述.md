#linux调度器概述
***
##一.linux进程的分类
###1.进程的分类
当涉及有关调度的问题时, 传统上把进程分类为”I/O受限(I/O-dound)”或”CPU受限(CPU-bound)”.
![](http://i.imgur.com/9K0JWxy.png)

另外一种分类法把进程区分为三类:
![](http://i.imgur.com/Qb1k4Qh.png)

###2.实时进程与普通进程
> 在linux中, 调度算法可以明确的确认所有实时进程的身份, 但是没办法区分交互式程序和批处理程序(统称为普通进程), linux2.6的调度程序实现了基于进程过去行为的启发式算法, 以确定进程应该被当做交互式进程还是批处理进程. 当然与批处理进程相比, 调度程序有偏爱交互式进程的倾向
> 
> 根据进程的不同分类Linux采用不同的调度策略.
> 
> 对于实时进程，采用FIFO或者Round Robin的调度策略.
> 
> 对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是”完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持.
> 
> 注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能.
> 
> linux进程的调度算法其实经过了很多次的演变, 但是其演变主要是针对与普通进程的, 因为前面我们提到过根据进程的不同分类Linux采用不同的调度策略.实时进程和普通进程采用了不同的调度策略, 更一般的普通进程还需要启发式的识别批处理进程和交互式进程.
> 
> 实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.
> 
> 但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢.
> 
> 此外如何进程中如果存在实时进程, 则实时进程总是在普通进程之前被调度.
> 
###3.linux调度器的演变
![](http://i.imgur.com/muujsZP.png)

##二.Linux的调度器设计
###1.linux进程调度器的框架
####2个调度器

> <code>可以用两种方法调度
> 
> 一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU
> 
> 另一种是通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要
> 
> 因此当前linux的调度程序由两个调度器组成：**主调度器**，**周期性调度器**(两者又统称为通用调度器(generic scheduler)或核心调度器(core scheduler))
> 
> 并且每个调度器包括两个内容：调度框架(其实质就是两个函数框架)及调度器类。</code>
####6种调度策略
<code>linux内核目前实现了6中调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能

比如SCHED\_NORMAL和SCHED\_BATCH调度普通的非实时进程, SCHED\_FIFO和SCHED\_RR和SCHED\_DEADLINE则采用不同的调度策略调度实时进程, SCHED\_IDLE则在系统空闲时调用idle进程.</code>
![](http://i.imgur.com/igPMNrY.png)
linux内核实现的6种调度策略, 前面三种策略使用的是cfs调度器类，后面两种使用rt调度器类, 最后一个使用DL调度器类

####5个调度器类

> 而依据其调度策略的不同实现了5个调度器类, 一个调度器类可以用一种种或者多种调度策略调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.
![](http://i.imgur.com/BnEPhuv.png)
其所属进程的优先级顺序为:<code>stop\_sched_class -> dl\_sched\_class -> rt\_sched\_class -> fair\_sched\_class -> idle\_sched\_class</code>

####3个调度实体
> 调度器不限于调度进程, 还可以调度更大的实体, 比如实现组调度: 可用的CPUI时间首先在一半的进程组(比如, 所有进程按照所有者分组)之间分配, 接下来分配的时间再在组内进行二次分配.
> 
> 这种一般性要求调度器不直接操作进程, 而是处理可调度实体, 因此需要一个通用的数据结构描述这个调度实体,即seched\_entity结构, 其实际上就代表了一个调度对象，可以为一个进程，也可以为一个进程组.
> 
linux中针对当前可调度的实时和非实时进程, 定义了类型为seched\_entity的3个调度实体:
![](http://i.imgur.com/r0AZLAi.png)

####调度器类的就绪队列


> 对于调度框架及调度器类，它们都有自己管理的运行队列，调度框架只识别rq（其实它也不能算是运行队列），而对于cfs调度器类它的运行队列则是cfs\_rq（内部使用红黑树组织调度实体），实时rt的运行队列则为rt\_rq（内部使用优先级bitmap+双向链表组织调度实体）, 此外内核对新增的dl实时调度策略也提供了运行队列dl\_rq.

####调度器整体框架

> 本质上, 通用调度器(核心调度器)是一个分配器,与其他两个组件交互.
> 
> 调度器用于判断接下来运行哪个进程. 
> 内核支持不同的调度策略(完全公平调度, 实时调度, 在无事可做的时候调度空闲进程,即0号进程也叫swapper进程,idle进程), 调度类使得能够以模块化的方法实现这些侧露额, 即一个类的代码不需要与其他类的代码交互 
> 当调度器被调用时, 他会查询调度器类, 得知接下来运行哪个进程
> 
> 在选中将要运行的进程之后, 必须执行底层的任务切换. 
> 这需要与CPU的紧密交互. 每个进程刚好属于某一调度类, 各个调度类负责管理所属的进程. 通用调度器自身不涉及进程管理, 其工作都委托给调度器类.
> 
> 每个进程都属于某个调度器类(由字段task\_struct->sched\_class标识), 由调度器类采用进程对应的调度策略调度(由task\_struct->policy )进行调度, task\_struct也存储了其对应的调度实体标识.



linux实现了6种调度策略, 依据其调度策略的不同实现了5个调度器类, 一个调度器类可以用一种或者多种调度策略调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.
![](http://i.imgur.com/oV9pq5V.png)


**它们的关系如下图:**

![](http://i.imgur.com/VXSYvJH.png)
